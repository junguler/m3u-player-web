<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>My Radio</title>
    <meta
      name="description"
      content="Simple web player for my M3U radio playlists."
    />
    <meta name="theme-color" content="#0b0f14" />
    <link
      rel="icon"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Ctext y='52' font-size='48'%3E%F0%9F%8E%A7%3C/text%3E%3C/svg%3E"
    />
    <style>
      /* Define CSS variables for theming */
      :root {
        --bg: #0b0f14;
        --bg-soft: #111824;
        --card: #0f1725;
        --text: #e6edf3;
        --muted: #aab6c3;
        --brand: #5fb1ff;
        --accent: #86efac;
        --border: #1f2937;
      }
      /* Light theme adaptation */
      @media (prefers-color-scheme: light) {
        :root {
          --bg: #f7f9fc;
          --bg-soft: #ffffff;
          --card: #ffffff;
          --text: #0b0f14;
          --muted: #4b5563;
          --brand: #2563eb;
          --accent: #16a34a;
          --border: #e5e7eb;
        }
      }
      /* Reset box-sizing */
      * {
        box-sizing: border-box;
      }
      /* Full height for html and body */
      html,
      body {
        height: 100%;
      }
      /* Body styles */
      body {
        margin: 0;
        font: 16px / 1.4
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          "helvetica neue",
          Noto Sans,
          Arial,
          "apple color emoji",
          "segoe ui emoji";
        color: var(--text);
        background: var(--bg);
      }
      /* Top bar styles */
      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 10;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: var(--bg-soft);
        border-bottom: 1px solid var(--border);
        backdrop-filter: saturate(1.2) blur(6px);
      }
      /* Brand text styles */
      .brand {
        font-weight: 700;
        letter-spacing: 0.2px;
        color: var(--brand);
        user-select: none;
        text-decoration: none;
      }
      /* Search input styles */
      #searchInput {
        flex: 1;
        appearance: none;
        border: 1px solid var(--border);
        background: var(--card);
        color: var(--text);
        border-radius: 10px;
        padding: 10px 12px;
        outline: none;
      }
      /* Search input placeholder styles */
      #searchInput::placeholder {
        color: var(--muted);
      }
      /* Main app content area */
      #app {
        max-width: 1100px;
        margin: 70px auto 96px;
        padding: 0 16px;
      }
      /* Loading, empty, error messages */
      .loading,
      .empty,
      .error {
        color: var(--muted);
        text-align: center;
        padding: 24px 12px;
      }
      /* Section title styles */
      .section-title {
        margin: 16px 0 10px;
        font-weight: 700;
        font-size: 18px;
      }
      /* Playlist meta info */
      .playlist-meta {
        color: var(--muted);
        font-size: 13px;
        margin-bottom: 16px;
      }
      /* Grid layout for cards */
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 12px;
      }
      /* Card styles */
      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        transition: transform 0.08s ease, border-color 0.08s ease;
        text-decoration: none;
        color: inherit;
      }
      /* Card hover effect */
      .card:hover {
        transform: translateY(-1px);
        border-color: #2b3a50;
      }
      /* Card title */
      .card .title {
        display: block;
        font-weight: 600;
        color: var(--text);
      }
      /* Card meta info */
      .card .meta {
        color: var(--muted);
        font-size: 13px;
      }
      /* Stations list */
      .stations {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
        margin: 0;
        padding: 0;
        list-style: none;
      }
      /* Individual station item */
      .station {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 10px;
        cursor: pointer;
      }
      /* Play button within station */
      .station .play {
        font-size: 18px;
        width: 40px;
        height: 40px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #111c2a;
        color: var(--text);
        cursor: pointer;
      }
      /* Station name */
      .station .name {
        font-weight: 600;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      /* Station actions container */
      .station .actions {
        display: flex;
        gap: 6px;
      }
      /* Open stream button */
      .station .open {
        border: 1px solid var(--border);
        background: 0 0;
        color: var(--muted);
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      /* Active station highlight */
      .station.active {
        outline: 2px solid var(--brand);
      }
      /* Audio player bar */
      .player {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        display: grid;
        grid-template-columns: auto auto auto auto 1fr auto;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border-top: 1px solid var(--border);
        background: linear-gradient(180deg, transparent, rgba(0, 0, 0, 6%)),
          var(--bg-soft);
        backdrop-filter: saturate(1.2) blur(6px);
      }
      /* Player buttons */
      .player button {
        height: 40px;
        width: 40px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #111c2a;
        color: var(--text);
        cursor: pointer;
      }
      /* Now playing info container */
      .player .now {
        min-width: 0;
      }
      /* Now playing station name */
      .now-station {
        font-weight: 700;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      /* Now playing song title */
      .now-song {
        color: var(--muted);
        font-size: 13px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      /* Now playing meta info */
      .now-meta {
        color: var(--muted);
        font-size: 12px;
        opacity: 0.9;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      /* Volume controls container */
      .volume {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      /* Volume percentage display */
      .volume-percentage {
        font-size: 13px;
        color: var(--muted);
        min-width: 4ch;
        text-align: right;
      }
      /* Volume range input width */
      #volumeRange {
        width: 100px;
      }
      /* Generic row styling */
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      /* Small text styling */
      .small {
        color: var(--muted);
        font-size: 13px;
      }
      /* Link styling */
      a.link {
        color: var(--brand);
        text-decoration: none;
      }
      a.link:hover {
        text-decoration: underline;
      }
    </style>
    <!-- Message for users with JavaScript disabled -->
    <noscript>This site needs JavaScript to load your playlists.</noscript>
  </head>
  <body>
    <!-- Top navigation bar -->
    <header class="topbar">
      <!-- Brand logo/name, links to home -->
      <a class="brand" id="brand" href="#/">üéß My Radio</a>
      <!-- Search input field -->
      <input
        type="search"
        id="searchInput"
        placeholder="Search‚Ä¶"
        autocomplete="off"
      />
    </header>

    <!-- Main application content area -->
    <main id="app">
      <!-- Initial loading message -->
      <div class="loading" id="appLoading">Loading‚Ä¶</div>
    </main>

    <!-- Audio player bar, hidden by default -->
    <footer class="player" id="playerBar" aria-label="Audio player" hidden>
      <!-- Playback control buttons -->
      <button id="prevBtn" title="Previous">‚èÆÔ∏è</button>
      <button id="playPauseBtn" title="Play/Pause">‚ñ∂Ô∏è</button>
      <button id="nextBtn" title="Next">‚è≠Ô∏è</button>
      <button id="shuffleBtn" title="Shuffle">üîÄ</button>

      <!-- Now playing information -->
      <div class="now">
        <div id="nowStation" class="now-station">No station selected</div>
        <div id="nowSong" class="now-song"></div>
        <div id="nowMeta" class="now-meta"></div>
      </div>

      <!-- Volume controls -->
      <div class="volume">
        <button id="muteBtn" title="Mute/Unmute">üîä</button>
        <button id="volDownBtn" title="Volume Down">-</button>
        <input
          id="volumeRange"
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="1"
        />
        <button id="volUpBtn" title="Volume Up">+</button>
        <span id="volumePercentage" class="volume-percentage">100%</span>
      </div>

      <!-- Actual audio element -->
      <audio id="audio" preload="none" crossorigin="anonymous"></audio>
    </footer>

    <script>
      "use strict"; // Enforce strict mode

      // Configuration object for API URL and site title
      const CONFIG = {
        API_INDEX_URL:
          "https://junguler.github.io/m3u-rest-api/api/index.json",
        SITE_TITLE: "My Radio",
      };

      // Object to store DOM elements for easy access
      const els = {};

      // State object to manage application data
      const state = {
        index: null, // Stores the main index data
        indexBase: null, // Base URL for the index
        indexDir: null, // Directory URL of the index
        repoRoot: null, // Root URL of the repository
        playlistMap: new Map(), // Map of slug to playlist data
        currentRoute: null, // Current route (e.g., "p" for playlist)
        currentSlug: null, // Slug of the current playlist
        currentPlaylist: null, // Full data of the current playlist
        currentPlaylistUrl: null, // URL from which the current playlist was loaded
        currentItems: [], // List of stream items in the current playlist
        currentIndex: -1, // Index of the currently playing stream
        audio: null, // Reference to the audio element
        audioContext: null, // Web Audio API context for normalization
        audioSource: null, // MediaElementSourceNode for audio element
        compressor: null, // DynamicsCompressorNode for audio normalization
        filter: "", // Current search filter string
        currentSong: "", // Currently playing song title
        streamMeta: {}, // Metadata for the current stream
      };

      // Event listener for DOM content loaded
      document.addEventListener("DOMContentLoaded", init);

      /**
       * Initializes the application.
       * Caches DOM elements, wires up UI events, and boots the application.
       */
      function init() {
        cacheDom();
        wireUI();
        boot();
      }

      /**
       * Caches frequently used DOM elements into the `els` object.
       */
      function cacheDom() {
        els.app = document.getElementById("app");
        els.appLoading = document.getElementById("appLoading");
        els.searchInput = document.getElementById("searchInput");
        els.playerBar = document.getElementById("playerBar");
        els.audio = document.getElementById("audio");
        els.playPauseBtn = document.getElementById("playPauseBtn");
        els.prevBtn = document.getElementById("prevBtn");
        els.nextBtn = document.getElementById("nextBtn");
        els.shuffleBtn = document.getElementById("shuffleBtn");
        els.muteBtn = document.getElementById("muteBtn");
        els.volumeRange = document.getElementById("volumeRange");
        els.volumePercentage = document.getElementById("volumePercentage");
        els.volUpBtn = document.getElementById("volUpBtn");
        els.volDownBtn = document.getElementById("volDownBtn");
        els.nowStation = document.getElementById("nowStation");
        els.nowSong = document.getElementById("nowSong");
        els.nowMeta = document.getElementById("nowMeta");
        els.brand = document.getElementById("brand");

        state.audio = els.audio; // Set audio element in state
        updateBrandText(); // Set initial brand text
        updateTitle(); // Set initial document title
      }

      /**
       * Wires up event listeners for user interface interactions.
       */
      function wireUI() {
        // Listen for hash changes in the URL (routing)
        window.addEventListener("hashchange", onRouteChange);
        // Debounced input for search field
        els.searchInput.addEventListener("input", debounce(onSearch, 120));
        // Player controls
        els.playPauseBtn.addEventListener("click", togglePlayPause);
        els.prevBtn.addEventListener("click", playPrev);
        els.nextBtn.addEventListener("click", playNext);
        els.shuffleBtn.addEventListener("click", shuffle);
        els.muteBtn.addEventListener("click", toggleMute);
        // Volume control
        els.volumeRange.addEventListener("input", () =>
          setVolume(parseFloat(els.volumeRange.value)),
        );
        els.volUpBtn.addEventListener("click", volumeUp);
        els.volDownBtn.addEventListener("click", volumeDown);

        // Audio element events
        els.audio.addEventListener("playing", () => updatePlayIcon(true));
        els.audio.addEventListener("pause", () => updatePlayIcon(false));
        els.audio.addEventListener("volumechange", updateVolumeDisplay);
        els.audio.addEventListener("error", onAudioError);
        // Update song info when time updates or metadata is loaded
        els.audio.addEventListener("timeupdate", updateCurrentSongInfo);
        els.audio.addEventListener("loadedmetadata", updateCurrentSongInfo);

        restoreVolume(); // Restore volume settings from last session
      }

      /**
       * Boots the application by fetching the playlist index and
       * handling initial routing.
       */
      async function boot() {
        try {
          showLoading(true); // Show loading indicator
          // Determine base URLs for API and repository
          state.indexBase = new URL(CONFIG.API_INDEX_URL, location.href);
          state.indexDir = new URL(".", state.indexBase.href);
          state.repoRoot = new URL("..", state.indexBase.href);

          // Fetch the main playlist index
          const indexData = await fetchJson(state.indexBase.href);
          state.index = indexData;
          buildPlaylistMap(indexData); // Build a map for quick playlist lookup

          // Handle initial route based on URL hash
          if (location.hash !== "#/") {
            onRouteChange();
          } else {
            // Force hashchange event if already on home, to render
            location.hash = "#/";
          }
        } catch (e) {
          // Display error if index loading fails
          showError(`Failed to load index: ${escapeHtml(e.message || e)}`);
        } finally {
          showLoading(false); // Hide loading indicator
        }
      }

      /**
       * Shows or hides the main loading indicator.
       * @param {boolean} show - Whether to show (true) or hide (false) the loading indicator.
       */
      function showLoading(show) {
        if (els.appLoading) {
          els.appLoading.classList.toggle("loading", !!show);
        }
        if (show) {
          // Clear app content and show loading message
          els.app.innerHTML = `<div class="loading">Loading‚Ä¶</div>`;
        }
      }

      /**
       * Displays an error message in the main app area.
       * @param {string} message - The error message to display.
       */
      function showError(message) {
        els.app.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
      }

      /**
       * Builds the `playlistMap` from the fetched index data.
       * @param {object} indexData - The index JSON object containing playlist information.
       */
      function buildPlaylistMap(indexData) {
        state.playlistMap.clear();
        const playlists = Array.isArray(indexData.playlists)
          ? indexData.playlists
          : [];
        for (const p of playlists) {
          const slug = slugFromPlaylist(p);
          const url = resolvePlaylistUrl(p.url);
          state.playlistMap.set(slug, {
            name: p.name || slug,
            url: url,
            count: p.count ?? null,
            raw: p, // Store raw playlist data if needed
          });
        }
      }

      /**
       * Generates a slug from a playlist object.
       * Tries to derive from URL, then falls back to name.
       * @param {object} playlist - The playlist object.
       * @returns {string} The generated slug.
       */
      function slugFromPlaylist(playlist) {
        if (playlist && playlist.url) {
          try {
            const part = playlist.url.split("/").pop() || "";
            if (part) {
              return part.replace(/\.json(\?.*)?$/i, "").toLowerCase();
            }
          } catch (e) {
            console.warn("Failed to parse slug from playlist URL:", e);
          }
        }
        return slugify(playlist?.name || "");
      }

      /**
       * Converts a string into a URL-friendly slug.
       * @param {string} text - The input string.
       * @returns {string} The slugified string.
       */
      function slugify(text) {
        return String(text)
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-") // Replace non-alphanumeric with hyphens
          .replace(/^-+|-+$/g, ""); // Remove leading/trailing hyphens
      }

      /**
       * Resolves a playlist URL relative to the index or repository root.
       * Handles absolute, protocol-relative, and relative paths.
       * @param {string} url - The playlist URL from the index.
       * @returns {string} The fully resolved URL.
       */
      function resolvePlaylistUrl(url) {
        if (!url) return "";
        // Absolute URL
        if (/^https?:\/\//i.test(url)) {
          return dedupeApi(url);
        }
        // Protocol-relative URL
        if (/^\/\//.test(url)) {
          return dedupeApi(location.protocol + url);
        }
        // Root-relative URL (relative to repository root)
        if (url.startsWith("/")) {
          return dedupeApi(new URL(url.replace(/^\//, ""), state.repoRoot).href);
        }
        // Relative to index directory or API directory
        if (url.startsWith("api/")) {
          return dedupeApi(new URL(url, state.repoRoot).href);
        }
        return dedupeApi(new URL(url, state.indexDir).href);
      }

      /**
       * Removes duplicate "/api" segments in a URL path.
       * E.g., "https://example.com/api/api/foo" becomes "https://example.com/api/foo"
       * @param {string} url - The URL string.
       * @returns {string} The URL with deduped "/api" segments.
       */
      function dedupeApi(url) {
        return url.replace(/(?:\/api)+(\/)/g, "/api$1");
      }

      /**
       * Handles changes in the URL hash, acting as a simple router.
       * Renders the appropriate view (home or playlist).
       */
      function onRouteChange() {
        const hashParts = getHashParts(); // Get parts of the hash (e.g., ["p", "my-playlist"])

        window.scrollTo(0, 0); // Scroll to top on route change
        els.searchInput.value = ""; // Clear search input
        state.filter = ""; // Clear current filter

        if (hashParts.length === 0) {
          // Home route
          state.currentRoute = "";
          state.currentSlug = null;
          renderHome();
          updateTitle();
          setSearchPlaceholder("Search playlists‚Ä¶");
          updateBrandText("home");
          return;
        }

        if (hashParts[0] === "p" && hashParts[1]) {
          // Playlist route (e.g., #/p/my-playlist)
          const slug = hashParts[1].toLowerCase();
          state.currentRoute = "p";
          state.currentSlug = slug;
          renderPlaylist(slug);
          setSearchPlaceholder("Search streams in this playlist‚Ä¶");
          updateBrandText("back");
          return;
        }

        // Default to home if route is not recognized
        state.currentRoute = "";
        state.currentSlug = null;
        renderHome();
        updateBrandText("home");
      }

      /**
       * Parses the URL hash into an array of parts.
       * @returns {string[]} An array of hash parts, e.g., ["p", "my-playlist"].
       */
      function getHashParts() {
        const hash = (location.hash || "").replace(/^#/, ""); // Remove leading '#'
        return hash.split("/").filter(Boolean); // Split by '/' and remove empty strings
      }

      /**
       * Updates the document title.
       * @param {string} [pageTitle] - The specific title for the current page.
       */
      function updateTitle(pageTitle) {
        document.title = pageTitle
          ? `${pageTitle} ‚Äî ${CONFIG.SITE_TITLE}`
          : CONFIG.SITE_TITLE;
      }

      /**
       * Updates the brand text/link in the top bar.
       * @param {"home"|"back"} [mode="home"] - Controls the text and behavior ("home" or "back" arrow).
       */
      function updateBrandText(mode = "home") {
        if (els.brand) {
          if (mode === "back") {
            els.brand.innerHTML = `&larr; Go Back`;
          } else {
            els.brand.textContent = `üéß ${CONFIG.SITE_TITLE}`;
          }
        }
      }

      /**
       * Sets the placeholder text for the search input.
       * @param {string} text - The placeholder text.
       */
      function setSearchPlaceholder(text) {
        els.searchInput.placeholder = text;
      }

      /**
       * Handles search input, filtering playlists or streams.
       * @param {Event} e - The input event.
       */
      function onSearch(e) {
        state.filter = e.target.value.trim().toLowerCase();
        if (state.currentRoute === "p" && state.currentPlaylist) {
          // If in a playlist, filter streams
          renderPlaylistContent(state.currentPlaylist, true);
        } else {
          // Otherwise, filter playlists on the home page
          renderHome(true);
        }
      }

      /**
       * Renders the home page, displaying a list of playlists.
       * @param {boolean} [isFiltered=false] - True if rendering due to a filter change.
       */
      function renderHome(isFiltered = false) {
        if (!state.index) {
          // If index not loaded, show loading state
          els.app.innerHTML = `<div class="loading">Loading‚Ä¶</div>`;
          return;
        }

        const filter = state.filter;
        // Convert playlist map to an array and filter if necessary
        const playlists = [...state.playlistMap.entries()].map(([slug, p]) => ({
          slug,
          ...p,
        }));
        const filteredPlaylists = filter
          ? playlists.filter(
              (p) =>
                p.name.toLowerCase().includes(filter) || p.slug.includes(filter),
            )
          : playlists;

        // Update title only if not a filtered refresh
        if (!isFiltered) {
          updateTitle();
        }

        // Display message if no playlists match the filter
        if (!filteredPlaylists.length) {
          els.app.innerHTML = `
            <div class="section-title">Playlists</div>
            <div class="empty">No playlists match ‚Äú${escapeHtml(filter)}‚Äù.</div>
          `;
          return;
        }

        // Create document fragment for efficient DOM updates
        const fragment = document.createDocumentFragment();

        // Section title
        const titleEl = document.createElement("div");
        titleEl.className = "section-title";
        titleEl.textContent = `Playlists ${filter ? `(filtered)` : ""}`;
        fragment.appendChild(titleEl);

        // Grid for playlist cards
        const gridEl = document.createElement("div");
        gridEl.className = "grid";

        // Create a card for each playlist
        for (const p of filteredPlaylists) {
          const cardEl = document.createElement("a");
          cardEl.className = "card";
          cardEl.href = `#/p/${p.slug}`;
          cardEl.innerHTML = `
            <span class="title">${escapeHtml(p.name)}</span>
            <span class="meta">${p.count ?? "‚Äî"} streams</span>
          `;
          gridEl.appendChild(cardEl);
        }
        fragment.appendChild(gridEl);

        // Replace existing app content
        els.app.replaceChildren(fragment);
      }

      /**
       * Renders a specific playlist, fetching its content if necessary.
       * @param {string} slug - The slug of the playlist to render.
       */
      async function renderPlaylist(slug) {
        const playlistMeta = state.playlistMap.get(slug);
        // Prioritize URL from playlistMap, otherwise construct a default
        const playlistUrl =
          playlistMeta?.url || resolvePlaylistUrl(`playlists/${slug}.json`);
        // List of candidate URLs to try fetching from
        const candidateUrls = unique([
          playlistUrl,
          resolvePlaylistUrl(`playlists/${slug}.json`), // Generic path
          resolvePlaylistUrl(`api/playlists/${slug}.json`), // API path
        ]);
        const playlistName = playlistMeta?.name || slug;

        updateTitle(playlistName); // Update document title
        els.app.innerHTML = `<div class="loading">Loading ‚Äú${escapeHtml(
          playlistName,
        )}‚Äù‚Ä¶</div>`; // Show loading

        try {
          // Fetch playlist data from the first successful URL
          const { url, data } = await fetchFirstOkJson(candidateUrls);
          state.currentPlaylist = data;
          state.currentPlaylistUrl = url;
          state.currentItems = Array.isArray(data.items) ? data.items : [];
          renderPlaylistContent(data); // Render the playlist's streams
        } catch (e) {
          // Display error if playlist loading fails
          const lastTried = e?.__lastTried || candidateUrls[candidateUrls.length - 1] || playlistUrl;
          console.error("Playlist fetch failed:", lastTried, e);
          els.app.innerHTML = `
            <div class="error">
              Failed to load playlist: ${escapeHtml(e.message || e)}<br/>
              Tried URL: <a class="link" href="${escapeHtml(
                lastTried,
              )}" target="_blank" rel="noopener">${escapeHtml(lastTried)}</a>
            </div>
          `;
        }
      }

      /**
       * Renders the content (streams) of a given playlist.
       * @param {object} playlistData - The playlist JSON object.
       * @param {boolean} [isFiltered=false] - True if rendering due to a filter change.
       */
      function renderPlaylistContent(playlistData, isFiltered = false) {
        const playlistName = playlistData.name || state.currentSlug || "Playlist";
        const totalStreams = playlistData.count ?? (playlistData.items?.length || 0);

        if (!isFiltered) {
          updateTitle(playlistName); // Update title if not a filtered refresh
        }

        const filter = state.filter;
        const allItems = state.currentItems || [];
        // Filter streams based on search input
        const filteredItems = filter
          ? allItems.filter((item) =>
              (item.name || "").toLowerCase().includes(filter),
            )
          : allItems;

        const fragment = document.createDocumentFragment();

        // Section title and stream count
        const titleRow = document.createElement("div");
        titleRow.className = "row";
        titleRow.innerHTML = `
          <div class="section-title">${escapeHtml(playlistName)}</div>
          <div class="small">Streams: ${filteredItems.length} ${
            filter ? `(filtered)` : `of ${totalStreams}`
          }</div>
        `;
        fragment.appendChild(titleRow);

        // Playlist metadata (source URL, generated date)
        if (
          state.currentPlaylistUrl ||
          playlistData.sourceFile ||
          playlistData.generatedAt
        ) {
          const metaDiv = document.createElement("div");
          metaDiv.className = "playlist-meta";
          const metaParts = [];
          if (state.currentPlaylistUrl) {
            const encodedUrl = escapeHtml(state.currentPlaylistUrl);
            metaParts.push(
              `Source: <a class="link" href="${encodedUrl}" target="_blank" rel="noopener">${encodedUrl}</a>`,
            );
          } else if (playlistData.sourceFile) {
            metaParts.push(`Source: ${escapeHtml(playlistData.sourceFile)}`);
          }
          if (playlistData.generatedAt) {
            metaParts.push(
              `Updated: ${escapeHtml(toLocalTime(playlistData.generatedAt))}`,
            );
          }
          metaDiv.innerHTML = metaParts.join(" ‚Ä¢ ");
          fragment.appendChild(metaDiv);
        }

        // Message if no streams match the filter
        if (!filteredItems.length) {
          const emptyDiv = document.createElement("div");
          emptyDiv.className = "empty";
          emptyDiv.textContent = `No streams match ‚Äú${state.filter}‚Äù.`;
          fragment.appendChild(emptyDiv);
          els.app.replaceChildren(fragment);
          return;
        }

        // List of stations
        const stationsList = document.createElement("ul");
        stationsList.className = "stations";

        // Create a list item for each stream
        filteredItems.forEach((item) => {
          const listItem = document.createElement("li");
          listItem.className = "station";

          // Highlight active station
          const isActive =
            state.currentIndex >= 0 && state.currentItems[state.currentIndex] === item;
          if (isActive) {
            listItem.classList.add("active");
          }

          // Play button
          const playButton = document.createElement("button");
          playButton.className = "play";
          playButton.title = "Play";
          playButton.textContent = "‚ñ∂Ô∏è";
          playButton.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent listItem click event
            const itemIndex = state.currentItems.findIndex(
              (i) => i === item || i.url === item.url,
            );
            if (itemIndex !== -1) {
              playFromList(state.currentItems, itemIndex);
            }
          });

          // Station name
          const nameDiv = document.createElement("div");
          nameDiv.className = "name";
          nameDiv.textContent = item.name || "(Unnamed)";

          // Actions container (e.g., open URL)
          const actionsDiv = document.createElement("div");
          actionsDiv.className = "actions";

          // Open URL button
          const openButton = document.createElement("button");
          openButton.className = "open";
          openButton.innerHTML = "‚Üó";
          openButton.title = "Open stream URL in new tab";
          openButton.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent listItem click event
            if (item.url) {
              window.open(item.url, "_blank", "noopener");
            }
          });
          actionsDiv.appendChild(openButton);

          listItem.appendChild(playButton);
          listItem.appendChild(nameDiv);
          listItem.appendChild(actionsDiv);

          // Click on list item to play
          listItem.addEventListener("click", () => {
            const itemIndex = state.currentItems.findIndex(
              (i) => i === item || i.url === item.url,
            );
            if (itemIndex !== -1) {
              playFromList(state.currentItems, itemIndex);
            }
          });

          stationsList.appendChild(listItem);
        });

        fragment.appendChild(stationsList);
        els.app.replaceChildren(fragment);
        refreshActiveStationHighlight(); // Ensure active station is highlighted and scrolled into view
      }

      /**
       * Plays a stream from the `currentItems` list.
       * @param {Array<object>} list - The list of stream items.
       * @param {number} index - The index of the item to play.
       */
      function playFromList(list, index) {
        const item = list[index];
        if (!item) return;

        state.currentIndex = index; // Update current index
        setNowPlaying(item); // Update now playing display
        loadAndPlay(item.url); // Load and play the audio
        refreshActiveStationHighlight(); // Update UI highlight
      }

      /**
       * Updates the now playing information in the player bar.
       * @param {object|null} item - The current stream item or null if none.
       */
      function setNowPlaying(item) {
        els.nowStation.textContent = item?.name || "Unknown Station";
        els.nowSong.textContent = ""; // Clear song title initially
        if (els.nowMeta) {
          els.nowMeta.textContent = ""; // Clear meta initially
        }
        state.currentSong = ""; // Clear current song in state
        state.streamMeta = {}; // Clear stream meta in state
        els.playerBar.hidden = false; // Show the player bar
        persistSession(); // Save session (to remember last played station)
        updateCurrentSongInfo(); // Update song info from audio element
        updateCurrentStreamMeta(item); // Update stream meta from item and probe
      }

      /**
       * Sets up the Web Audio API for audio normalization (dynamics compressor).
       * This is done only once when audio starts playing.
       */
      function setupAudioNormalization() {
        if (state.audioContext) return; // Already setup

        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          state.audioContext = new AudioContext();
          state.audioSource = state.audioContext.createMediaElementSource(
            els.audio,
          );
          state.compressor = state.audioContext.createDynamicsCompressor();

          // Compressor parameters for normalization
          state.compressor.threshold.setValueAtTime(
            -50,
            state.audioContext.currentTime,
          );
          state.compressor.knee.setValueAtTime(
            40,
            state.audioContext.currentTime,
          );
          state.compressor.ratio.setValueAtTime(
            12,
            state.audioContext.currentTime,
          );
          state.compressor.attack.setValueAtTime(
            0,
            state.audioContext.currentTime,
          );
          state.compressor.release.setValueAtTime(
            0.25,
            state.audioContext.currentTime,
          );

          // Connect nodes: audio source -> compressor -> destination
          state.audioSource.connect(state.compressor);
          state.compressor.connect(state.audioContext.destination);
        } catch (e) {
          console.error("Failed to initialize Web Audio API for normalization:", e);
        }
      }

      /**
       * Attempts to play the audio element.
       */
      function playAudio() {
        if (!els.audio.src) return;

        // Setup audio context if not already done
        if (!state.audioContext) {
          setupAudioNormalization();
        }

        // Resume audio context if suspended (e.g., after user interaction)
        if (state.audioContext && state.audioContext.state === "suspended") {
          state.audioContext.resume().catch((e) => {
            console.error("Audio context resume failed:", e);
          });
        }

        // Play the audio, handling potential Autoplay Policy errors
        els.audio.play().catch((e) => {
          if (e.name !== "AbortError") {
            // AbortError is common and expected if user pauses immediately
            console.warn("Audio play failed:", e);
          }
        });
      }

      /**
       * Pauses the audio element.
       */
      function pauseAudio() {
        els.audio.pause();
      }

      /**
       * Loads a new audio source and attempts to play it.
       * @param {string} url - The URL of the audio stream.
       */
      function loadAndPlay(url) {
        try {
          els.audio.src = url || ""; // Set new source or clear it
          if (!url) {
            pauseAudio(); // If no URL, stop playback
            return;
          }
          playAudio();
        } catch (e) {
          console.error("Audio error:", e);
        }
      }

      /**
       * Toggles play/pause state of the audio.
       */
      function togglePlayPause() {
        if (!els.audio.src) return; // Cannot play if no source
        if (els.audio.paused) {
          playAudio();
        } else {
          pauseAudio();
        }
      }

      /**
       * Updates the play/pause button icon.
       * @param {boolean} isPlaying - True if audio is playing, false otherwise.
       */
      function updatePlayIcon(isPlaying) {
        els.playPauseBtn.textContent = isPlaying ? "‚è∏Ô∏è" : "‚ñ∂Ô∏è";
      }

      /**
       * Plays the next stream in the current playlist.
       * Cycles back to the beginning if at the end.
       */
      function playNext() {
        if (!state.currentItems.length) return;
        const nextIndex = (state.currentIndex + 1) % state.currentItems.length;
        state.currentIndex = nextIndex;
        const nextItem = state.currentItems[nextIndex];
        setNowPlaying(nextItem);
        loadAndPlay(nextItem.url);
        refreshActiveStationHighlight();
      }

      /**
       * Plays the previous stream in the current playlist.
       * Cycles back to the end if at the beginning.
       */
      function playPrev() {
        if (!state.currentItems.length) return;
        const prevIndex =
          (state.currentIndex - 1 + state.currentItems.length) %
          state.currentItems.length;
        state.currentIndex = prevIndex;
        const prevItem = state.currentItems[prevIndex];
        setNowPlaying(prevItem);
        loadAndPlay(prevItem.url);
        refreshActiveStationHighlight();
      }

      /**
       * Shuffles to a random stream or a random playlist.
       * If in a playlist, shuffles to a random stream within it.
       * Otherwise, shuffles to a random playlist and navigates there.
       */
      async function shuffle() {
        if (state.currentRoute === "p" && state.currentItems.length > 0) {
          // Shuffle within current playlist
          const randomIndex = Math.floor(
            Math.random() * state.currentItems.length,
          );
          playFromList(state.currentItems, randomIndex);
        } else if (state.playlistMap.size > 0) {
          // Shuffle to a random playlist
          const playlistSlugs = Array.from(state.playlistMap.keys());
          const randomSlug =
            playlistSlugs[Math.floor(Math.random() * playlistSlugs.length)];
          location.hash = `#/p/${randomSlug}`; // Navigate to random playlist
        }
      }

      /**
       * Toggles the mute state of the audio.
       */
      function toggleMute() {
        els.audio.muted = !els.audio.muted;
        persistVolume(); // Save mute state
      }

      /**
       * Updates the mute button icon based on the audio's mute state.
       */
      function updateMuteIcon() {
        const isMuted = els.audio.muted || els.audio.volume === 0;
        els.muteBtn.textContent = isMuted ? "üîá" : "üîä";
      }

      /**
       * Updates the volume range slider, percentage display, and mute icon.
       */
      function updateVolumeDisplay() {
        els.volumeRange.value = els.audio.volume;
        els.volumePercentage.textContent = `${Math.round(
          els.audio.volume * 100,
        )}%`;
        updateMuteIcon();
        persistVolume(); // Save volume settings
      }

      /**
       * Sets the audio volume, clamping it between 0 and 1.
       * @param {number} volume - The desired volume level.
       */
      function setVolume(volume) {
        els.audio.volume = Math.max(0, Math.min(1, volume));
      }

      /**
       * Increases the volume by a small increment.
       */
      function volumeUp() {
        setVolume(els.audio.volume + 0.1);
      }

      /**
       * Decreases the volume by a small increment.
       */
      function volumeDown() {
        setVolume(els.audio.volume - 0.1);
      }

      /**
       * Handles audio errors, logging a warning and clearing song info.
       */
      function onAudioError() {
        console.warn("Audio error", els.audio.error);
        els.nowSong.textContent = "";
      }

      /**
       * Updates the current song information displayed in the player bar.
       * Tries to get title from metadata (ICY or MediaSession) or audio element title.
       */
      function updateCurrentSongInfo() {
        let songTitle = "";

        // Check for ICY metadata in text tracks
        if (els.audio.textTracks && els.audio.textTracks.length > 0) {
          const icyTrack = Array.from(els.audio.textTracks).find(
            (t) => t.kind === "metadata",
          );
          if (icyTrack) {
            // Remove previous listener to avoid duplicates
            icyTrack.oncuechange = null;
            icyTrack.oncuechange = () => {
              if (icyTrack.activeCues.length > 0) {
                const cue = icyTrack.activeCues[0];
                const match = /StreamTitle='([^;]+)';/.exec(cue.text);
                songTitle = match && match[1] ? match[1] : cue.text;
              } else {
                songTitle = "";
              }
              els.nowSong.textContent = songTitle || "";
              state.currentSong = songTitle || "";
              renderMetaLine(); // Re-render meta line to include song title
            };

            // If cues already exist, process them immediately
            if (icyTrack.activeCues.length > 0) {
              const cue = icyTrack.activeCues[0];
              const match = /StreamTitle='([^;]+)';/.exec(cue.text);
              songTitle = match && match[1] ? match[1] : cue.text;
            }
          }
        }

        // Fallback to Media Session API metadata
        if (
          !songTitle &&
          navigator.mediaSession &&
          navigator.mediaSession.metadata &&
          navigator.mediaSession.metadata.title
        ) {
          songTitle = navigator.mediaSession.metadata.title;
        }

        // Fallback to audio element title attribute
        if (!songTitle && els.audio.title) {
          songTitle = els.audio.title;
        }

        els.nowSong.textContent = songTitle || "";
        state.currentSong = songTitle || "";
        renderMetaLine(); // Re-render meta line to include song title
      }

      /**
       * Refreshes the active station highlight in the playlist view.
       * Scrolls the active station into view if it's not visible.
       */
      function refreshActiveStationHighlight() {
        const stationEls = Array.from(document.querySelectorAll(".station"));
        stationEls.forEach((el) => el.classList.remove("active")); // Remove all active highlights

        if (state.currentIndex >= 0 && state.currentIndex < state.currentItems.length) {
          const currentItem = state.currentItems[state.currentIndex];
          for (const el of stationEls) {
            const nameEl = el.querySelector(".name");
            // Match by name or URL (if name not found)
            if (
              nameEl &&
              currentItem &&
              nameEl.textContent === (currentItem.name || "")
            ) {
              el.classList.add("active");
              // Scroll active station into view smoothly
              el.scrollIntoView({ behavior: "smooth", block: "nearest" });
              break;
            }
          }
        }
      }

      /**
       * Persists the current session state (e.g., current playlist, index, volume)
       * to local storage. (Currently commented out in its full form, only volume is persisted).
       */
      function persistSession() {
        try {
          const sessionData = {
            slug: state.currentSlug,
            index: state.currentIndex,
            // volume: els.audio.volume, // Volume is persisted separately
            // muted: els.audio.muted,   // Muted state is persisted separately
            station: state.currentItems[state.currentIndex] || null,
          };
          // localStorage.setItem("radio:session", JSON.stringify(sessionData));
        } catch (e) {
          console.error("Failed to persist session:", e);
        }
      }

      /**
       * Restores the last session state from local storage.
       * (Currently a placeholder, as full session restore is more complex.)
       */
      function restoreLastSession() {
        // try {
        //   const stored = localStorage.getItem("radio:session");
        //   if (stored) {
        //     const sessionData = JSON.parse(stored);
        //     // Logic to restore: navigate to playlist, find station, start playing
        //     // This part is more complex and depends on the application's lifecycle
        //   }
        // } catch (e) {
        //   console.error("Failed to restore session:", e);
        // }
      }

      /**
       * Persists the audio volume and mute state to local storage.
       */
      function persistVolume() {
        try {
          const stored = localStorage.getItem("radio:last");
          const data = stored ? JSON.parse(stored) : {};
          data.volume = els.audio.volume;
          data.muted = els.audio.muted;
          localStorage.setItem("radio:last", JSON.stringify({ volume: data.volume, muted: data.muted }));
        } catch (e) {
          console.error("Failed to persist volume:", e);
        }
      }

      /**
       * Restores the audio volume and mute state from local storage.
       */
      function restoreVolume() {
        try {
          const stored = localStorage.getItem("radio:last");
          const data = stored ? JSON.parse(stored) : {};
          if (typeof data.volume === "number") {
            els.audio.volume = data.volume;
          }
          els.audio.muted = !!data.muted; // Ensure boolean
          updateVolumeDisplay(); // Update UI to reflect restored volume/mute
        } catch (e) {
          console.error("Failed to restore volume:", e);
        }
      }

      /**
       * Fetches JSON data from a given URL.
       * @param {string} url - The URL to fetch from.
       * @returns {Promise<object>} A promise that resolves with the JSON data.
       * @throws {Error} If the fetch request fails or the response is not OK.
       */
      async function fetchJson(url) {
        const response = await fetch(url, {
          headers: { Accept: "application/json" },
          cache: "no-store", // Always fetch fresh data for JSON index/playlists
        });
        if (!response.ok) {
          throw new Error(`${response.status} ${response.statusText}`);
        }
        return response.json();
      }

      /**
       * Tries to fetch JSON from a list of URLs, returning the first successful response.
       * @param {string[]} urls - An array of URLs to try.
       * @returns {Promise<{url: string, data: object}>} A promise that resolves with the URL and JSON data of the first successful fetch.
       * @throws {Error} If all URLs fail to fetch.
       */
      async function fetchFirstOkJson(urls) {
        let lastError = null;
        for (const url of urls) {
          try {
            const data = await fetchJson(url);
            return { url: url, data: data };
          } catch (e) {
            lastError = e;
          }
        }
        if (lastError) {
          lastError.__lastTried = urls[urls.length - 1]; // Store the last tried URL for debugging
          throw lastError;
        }
        throw new Error("All candidate URLs failed");
      }

      /**
       * Escapes HTML special characters in a string to prevent XSS.
       * @param {string} text - The input string.
       * @returns {string} The HTML-escaped string.
       */
      function escapeHtml(text) {
        return String(text)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      /**
       * Creates a debounced version of a function.
       * The debounced function will only be called after a specified delay
       * since the last time it was invoked.
       * @param {Function} func - The function to debounce.
       * @param {number} [delay=100] - The debounce delay in milliseconds.
       * @returns {Function} The debounced function.
       */
      function debounce(func, delay = 100) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(null, args), delay);
        };
      }

      /**
       * Converts an ISO 8601 timestamp to a localized date/time string.
       * @param {string} isoTimestamp - The ISO 8601 timestamp string.
       * @returns {string} The localized date/time string, or the original timestamp if conversion fails.
       */
      function toLocalTime(isoTimestamp) {
        try {
          return new Date(isoTimestamp).toLocaleString();
        } catch {
          return isoTimestamp;
        }
      }

      /**
       * Shortens a URL path, showing only the hostname if it's external,
       * or just the pathname if it's on the same host.
       * @param {string} url - The URL string.
       * @returns {string} The shortened path or URL.
       */
      function shortenPath(url) {
        try {
          const u = new URL(url);
          const sameHost = u.host === location.host;
          return (sameHost ? "" : `${u.host}`) + u.pathname;
        } catch {
          return url;
        }
      }

      /**
       * Returns an array with only unique, truthy elements.
       * @param {Array<any>} arr - The input array.
       * @returns {Array<any>} An array of unique, truthy elements.
       */
      function unique(arr) {
        return Array.from(new Set(arr.filter(Boolean)));
      }

      /**
       * Updates the `streamMeta` state object and triggers a re-render of the meta line.
       * Also initiates probes for additional stream metadata.
       * @param {object} item - The current stream item.
       */
      function updateCurrentStreamMeta(item) {
        const streamUrl = item?.url || "";
        // Extract host from URL
        const host = (() => {
          try {
            return new URL(streamUrl).host;
          } catch {
            return "";
          }
        })();

        // Guess codec from URL extension
        const guessedCodec = guessCodecFromUrl(streamUrl);

        // Parse bitrate, handling string-to-number conversion
        let bitrate = item?.bitrate ?? item?.br ?? item?.["icy-br"] ?? null;
        if (typeof bitrate === "string") {
          bitrate = parseInt(bitrate, 10);
        }

        // Parse sample rate
        let sampleRate = item?.sampleRate ?? item?.samplerate;
        // Parse channels
        let channels = item?.channels;

        // Initialize streamMeta with known data from playlist item
        state.streamMeta = {
          host: host,
          codec: (item?.codec || item?.format || guessedCodec || "")
            .toString()
            .toUpperCase(),
          bitrate: typeof bitrate === "number" && !isNaN(bitrate) ? bitrate : null,
          sampleRate:
            typeof sampleRate === "number" && !isNaN(sampleRate) ? sampleRate : null,
          channels:
            typeof channels === "number" && !isNaN(channels) ? channels : null,
          genre: item?.genre || "",
          server: "", // Will be filled by probes
          listeners: null, // Will be filled by probes
          stationName: item?.name || "", // Initial station name
        };

        renderMetaLine(); // Render meta line with initial data

        // Probe for more metadata asynchronously
        probeStreamHeaders(streamUrl)
          .then((meta) => {
            if (meta) applyMeta(meta);
          })
          .finally(renderMetaLine); // Re-render after headers probe

        probeServerStatus(streamUrl)
          .then((meta) => {
            if (meta) applyMeta(meta);
          })
          .finally(renderMetaLine); // Re-render after server status probe

        probeIcyMetadata(streamUrl)
          .then((meta) => {
            if (meta) applyMeta(meta);
          })
          .finally(renderMetaLine); // Re-render after ICY metadata probe
      }

      /**
       * Applies new metadata to the `state.streamMeta` object,
       * prioritizing new non-empty values.
       * Updates `state.currentSong` if a title is found.
       * @param {object} newMeta - The new metadata object.
       */
      function applyMeta(newMeta) {
        if (!newMeta) return;

        // List of keys to update in streamMeta
        const keysToUpdate = [
          "codec",
          "bitrate",
          "sampleRate",
          "channels",
          "genre",
          "server",
          "listeners",
          "stationName",
          "host",
        ];

        for (const key of keysToUpdate) {
          // Update only if new value is not null/empty and not NaN for numbers
          if (
            newMeta[key] != null &&
            newMeta[key] !== "" &&
            !(typeof newMeta[key] === "number" && isNaN(newMeta[key]))
          ) {
            state.streamMeta[key] = newMeta[key];
          }
        }

        // Update current song title if present
        if (newMeta.title) {
          state.currentSong = newMeta.title;
          els.nowSong.textContent = newMeta.title;
        }

        renderMetaLine(); // Re-render the meta line after applying updates
      }

      /**
       * Renders the current stream metadata into the `nowMeta` element.
       */
      function renderMetaLine() {
        if (!els.nowMeta) return;

        const meta = state.streamMeta || {};
        const parts = [];

        // Add current song if available
        if (state.currentSong) {
          parts.push(state.currentSong);
        }

        // Add codec if available
        if (meta.codec) {
          parts.push(meta.codec);
        }

        // Add bitrate if available and valid
        if (typeof meta.bitrate === "number" && !isNaN(meta.bitrate)) {
          parts.push(`${meta.bitrate} kbps`);
        }

        // Add sample rate if available and valid
        if (typeof meta.sampleRate === "number" && !isNaN(meta.sampleRate)) {
          parts.push(`${meta.sampleRate} Hz`);
        }

        // Add channel info if available and valid
        if (typeof meta.channels === "number" && !isNaN(meta.channels)) {
          if (meta.channels === 1) parts.push("Mono");
          else if (meta.channels === 2) parts.push("Stereo");
          else parts.push(`${meta.channels}ch`);
        }

        // Add genre if available
        if (meta.genre) {
          parts.push(meta.genre);
        }

        // Add listener count if available and valid
        if (typeof meta.listeners === "number" && !isNaN(meta.listeners)) {
          parts.push(`${meta.listeners} listeners`);
        }

        // Add server info if available
        if (meta.server) {
          parts.push(meta.server);
        }

        // Add host if available
        if (meta.host) {
          parts.push(meta.host);
        }

        // Join all parts with a " ‚Ä¢ " separator
        els.nowMeta.textContent = parts.join(" ‚Ä¢ ");
      }

      /**
       * Guesses the audio codec based on the stream URL's file extension.
       * @param {string} url - The stream URL.
       * @returns {string} The guessed codec (e.g., "MP3", "AAC", "HLS"), or an empty string.
       */
      function guessCodecFromUrl(url) {
        try {
          const pathname = new URL(url).pathname.toLowerCase();
          if (pathname.endsWith(".m3u8")) return "HLS";
          if (pathname.endsWith(".aac") || pathname.endsWith(".aacp"))
            return "AAC";
          if (pathname.endsWith(".mp3")) return "MP3";
          if (pathname.endsWith(".ogg") || pathname.endsWith(".oga"))
            return "OGG";
          if (pathname.endsWith(".opus")) return "OPUS";
          if (pathname.endsWith(".flac")) return "FLAC";
        } catch (e) {
          console.warn("Error guessing codec from URL:", e);
        }
        return "";
      }

      /**
       * Maps a Content-Type header string to a known audio codec name.
       * @param {string} contentType - The Content-Type string.
       * @returns {string} The mapped codec (e.g., "MP3", "AAC", "HLS"), or an empty string.
       */
      function mapContentTypeToCodec(contentType) {
        const type = (contentType || "").toLowerCase();
        if (type.includes("aac")) return "AAC";
        if (type.includes("mpeg")) return "MP3";
        if (type.includes("ogg")) return "OGG";
        if (type.includes("opus")) return "OPUS";
        if (type.includes("flac")) return "FLAC";
        if (type.includes("x-mpegurl") || type.includes("vnd.apple.mpegurl"))
          return "HLS";
        return "";
      }

      /**
       * Parses an "Ice-Audio-Info" header string into an object of key-value pairs.
       * Example: "bitrate=128;samplerate=44100;channels=2"
       * @param {string} infoString - The Ice-Audio-Info string.
       * @returns {object} An object containing the parsed audio info.
       */
      function parseIceAudioInfo(infoString) {
        const info = {};
        String(infoString || "")
          .split(/[;,]/)
          .forEach((part) => {
            const [key, value] = part.split("=");
            if (key && value) {
              info[key.trim().toLowerCase()] = value.trim();
            }
          });
        return info;
      }

      /**
       * Fetches a URL with a specified timeout.
       * @param {string} url - The URL to fetch.
       * @param {object} [options={}] - Fetch options.
       * @param {number} [timeout=4000] - The timeout in milliseconds.
       * @returns {Promise<Response|null>} The fetch Response object, or null if timed out/failed.
       */
      async function fetchWithTimeout(url, options = {}, timeout = 4000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        try {
          const response = await fetch(url, { ...options, signal: controller.signal });
          clearTimeout(id);
          return response;
        } catch {
          return null; // Return null on any error including abort
        }
      }

      /**
       * Fetches JSON from a URL with a timeout.
       * @param {string} url - The URL to fetch JSON from.
       * @param {number} [timeout=4500] - The timeout in milliseconds.
       * @returns {Promise<object|null>} The JSON object, or null if fetch fails or times out.
       */
      async function fetchJsonTimeout(url, timeout = 4500) {
        const response = await fetchWithTimeout(
          url,
          {
            headers: { Accept: "application/json" },
            mode: "cors",
            cache: "no-store",
          },
          timeout,
        );

        if (response && response.ok) {
          try {
            return await response.json();
          } catch {
            return null; // JSON parsing failed
          }
        }
        return null; // Fetch failed or not OK
      }

      /**
       * Probes a stream URL's HTTP headers for metadata (Content-Type, Icy-Genre, Icy-Br, Ice-Audio-Info).
       * Tries HEAD request first, then GET (with Range header for minimal data).
       * @param {string} streamUrl - The URL of the audio stream.
       * @returns {Promise<object|null>} An object containing parsed metadata, or null if no info found.
       */
      async function probeStreamHeaders(streamUrl) {
        if (!streamUrl) return null;

        const fetchWithOptions = async (method) =>
          await fetchWithTimeout(
            streamUrl,
            {
              method: method,
              mode: "cors",
              cache: "no-store",
              redirect: "follow", // Follow redirects
              headers: {
                "Icy-MetaData": "1", // Request ICY metadata
                ...(method === "GET" ? { Range: "bytes=0-1" } : {}), // For GET, only request 1 byte
              },
            },
            3500, // Timeout for header probes
          );

        let response = await fetchWithOptions("HEAD"); // Try HEAD first
        if (!response || !response.ok) {
          response = await fetchWithOptions("GET"); // Fallback to GET
        }

        if (!response || !response.ok) {
          return null;
        }

        const headers = response.headers;
        const meta = {};

        // Content-Type -> Codec
        const contentType =
          headers.get("content-type") || headers.get("Content-Type") || "";
        meta.codec = mapContentTypeToCodec(contentType) || "";

        // Server header
        meta.server = (headers.get("server") || headers.get("Server") || "")
          ?.split("/")[0]
          ?.trim() || "";

        // Icy-Genre
        const icyGenre = headers.get("icy-genre") || headers.get("Icy-Genre");
        if (icyGenre) {
          meta.genre = icyGenre;
        }

        // Icy-Br (bitrate)
        const icyBr = headers.get("icy-br");
        if (icyBr) {
          const br = parseInt(icyBr, 10);
          if (!isNaN(br)) {
            meta.bitrate = br;
          }
        }

        // Ice-Audio-Info (more detailed audio info)
        const iceAudioInfo =
          headers.get("ice-audio-info") || headers.get("Ice-Audio-Info") || "";
        if (iceAudioInfo) {
          const parsedInfo = parseIceAudioInfo(iceAudioInfo);
          if (parsedInfo.bitrate) {
            const br = parseInt(parsedInfo.bitrate, 10);
            if (!isNaN(br)) meta.bitrate = br;
          }
          if (parsedInfo.samplerate) {
            const sr = parseInt(parsedInfo.samplerate, 10);
            if (!isNaN(sr)) meta.sampleRate = sr;
          }
          if (parsedInfo.channels) {
            const ch = parseInt(parsedInfo.channels, 10);
            if (!isNaN(ch)) meta.channels = ch;
          }
        }

        return meta;
      }

      /**
       * Probes common Icecast/Shoutcast status pages for metadata.
       * @param {string} streamUrl - The URL of the audio stream.
       * @returns {Promise<object|null>} An object containing parsed metadata, or null if no info found.
       */
      async function probeServerStatus(streamUrl) {
        let urlObj;
        try {
          urlObj = new URL(streamUrl);
        } catch {
          return null; // Invalid URL
        }

        const origin = urlObj.origin;
        const pathname = urlObj.pathname || "";

        // Common status page URLs to try
        const candidateStatusUrls = unique([
          // Icecast-specific mountpoint status
          `${origin}/status-json.xsl?mount=${encodeURIComponent(pathname)}`,
          // Generic Icecast status
          `${origin}/status-json.xsl`,
          `${origin}/status.xsl?json=1`,
          // Shoutcast/other status
          `${origin}/stats?json=1`,
          `${origin}/statistics?json=1`,
          `${origin}/json.xsl`,
        ]);

        for (const statusUrl of candidateStatusUrls) {
          const data = await fetchJsonTimeout(statusUrl, 4500); // Fetch with timeout
          if (!data) continue;

          const parsedMeta = parseServerStatus(data, urlObj);
          if (parsedMeta) return parsedMeta;
        }
        return null;
      }

      /**
       * Parses the JSON response from an Icecast/Shoutcast status page.
       * @param {object} jsonData - The JSON data from the status page.
       * @param {URL} streamUrlObj - The URL object of the original stream.
       * @returns {object|null} An object containing parsed metadata, or null if no relevant info.
       */
      function parseServerStatus(jsonData, streamUrlObj) {
        // Icecast v2 status-json.xsl format
        if (jsonData.icestats) {
          const icestats = jsonData.icestats;
          const sources = Array.isArray(icestats.source)
            ? icestats.source
            : icestats.source
              ? [icestats.source]
              : [];
          const mountpointPath = streamUrlObj?.pathname || "";

          let relevantSource = sources[0] || null;

          // If multiple sources, try to find the one matching the current stream's mountpoint
          if (mountpointPath && sources.length > 1) {
            const exactMatch = sources.find((src) => {
              try {
                return src.listenurl && new URL(src.listenurl).pathname === mountpointPath;
              } catch {
                return false;
              }
            });
            relevantSource = exactMatch || sources.find(src => String(src.listenurl || "").includes(mountpointPath)) || relevantSource;
          }
          
          if (!relevantSource) return null;

          const meta = {};
          const audioInfo = relevantSource["audio_info"] || relevantSource["ice-audio-info"] || "";
          const parsedAudioInfo = parseIceAudioInfo(audioInfo);

          // Bitrate
          if (relevantSource.bitrate) {
            const br = parseInt(relevantSource.bitrate, 10);
            if (!isNaN(br)) meta.bitrate = br;
          }
          if (parsedAudioInfo.bitrate) {
            const br = parseInt(parsedAudioInfo.bitrate, 10);
            if (!isNaN(br)) meta.bitrate = br;
          }
          // Sample rate
          if (parsedAudioInfo.samplerate) {
            const sr = parseInt(parsedAudioInfo.samplerate, 10);
            if (!isNaN(sr)) meta.sampleRate = sr;
          }
          // Channels
          if (parsedAudioInfo.channels) {
            const ch = parseInt(parsedAudioInfo.channels, 10);
            if (!isNaN(ch)) meta.channels = ch;
          }
          // Genre
          if (relevantSource.genre) meta.genre = relevantSource.genre;
          // Listeners
          if (relevantSource.listeners != null) {
            const listeners = parseInt(relevantSource.listeners, 10);
            if (!isNaN(listeners)) meta.listeners = listeners;
          }
          // Station Name
          if (relevantSource.server_name) meta.stationName = relevantSource.server_name;
          // Codec from server type
          if (relevantSource.server_type) {
            meta.codec = meta.codec || mapContentTypeToCodec(String(relevantSource.server_type));
          }
          // Title
          if (relevantSource.title) meta.title = relevantSource.title;

          return meta;
        }

        // Shoutcast 1/2 JSON status format (simplified)
        if (jsonData.streams || jsonData.songtitle || jsonData.currentlisteners != null) {
          let streamData = null;
          if (jsonData.streams) {
            // Shoutcast 2 might have a 'streams' array or single 'stream' object
            let streams = jsonData.streams.stream || jsonData.streams;
            if (Array.isArray(streams)) {
              streamData = streams[0]; // Take the first stream
            } else if (typeof streams === "object") {
              streamData = streams; // It's already the single stream object
            }
          } else {
            // Might be flat Shoutcast 1-like JSON
            streamData = jsonData;
          }

          const meta = {};
          if (streamData) {
            if (streamData.bitrate) {
              const br = parseInt(streamData.bitrate, 10);
              if (!isNaN(br)) meta.bitrate = br;
            }
            if (streamData.currentlisteners != null) {
              const listeners = parseInt(streamData.currentlisteners, 10);
              if (!isNaN(listeners)) meta.listeners = listeners;
            }
            if (streamData.servergenre) meta.genre = streamData.servergenre;
            if (streamData.servertitle) meta.stationName = streamData.servertitle;
            if (streamData.songtitle) meta.title = streamData.songtitle;
            if (streamData.contenttype) {
              meta.codec = mapContentTypeToCodec(String(streamData.contenttype));
            }
          }
          return meta;
        }

        return null;
      }

      /**
       * Probes for ICY metadata by reading a small chunk of the stream.
       * This method requests the "Icy-MetaData: 1" header and then reads
       * `Icy-MetaInt` bytes + 1 + metadata-size bytes from the stream.
       * @param {string} streamUrl - The URL of the audio stream.
       * @param {number} [timeout=7000] - The timeout for the fetch request in milliseconds.
       * @returns {Promise<object|null>} An object containing parsed metadata (title, station name), or null if none.
       */
      async function probeIcyMetadata(streamUrl, timeout = 7000) {
        try {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);

          const response = await fetch(streamUrl, {
            method: "GET",
            mode: "cors",
            cache: "no-store",
            headers: { "Icy-MetaData": "1" }, // Request ICY metadata
            signal: controller.signal,
          });

          clearTimeout(id);

          if (!response || !response.ok || !response.body) return null;

          const metaInterval = parseInt(
            response.headers.get("icy-metaint") ||
              response.headers.get("Icy-MetaInt") ||
              "",
            10,
          );
          const icyStationName =
            response.headers.get("icy-name") || response.headers.get("Icy-Name") || "";

          // If no meta interval, no ICY metadata (except possibly station name)
          if (!metaInterval || isNaN(metaInterval)) {
            return icyStationName ? { stationName: icyStationName } : null;
          }

          const reader = response.body.getReader();
          let bufferedData = new Uint8Array(0);

          /** Helper to consume N bytes, updating bufferedData. */
          const consumeBytes = async (n) => {
            if (bufferedData.length) {
              if (bufferedData.length >= n) {
                bufferedData = bufferedData.subarray(n);
                return;
              }
              n -= bufferedData.length;
              bufferedData = new Uint8Array(0);
            }

            while (n > 0) {
              const { value, done } = await reader.read();
              if (done) return; // Stream ended unexpectedly
              if (value.length <= n) {
                n -= value.length;
              } else {
                bufferedData = value.subarray(n);
                n = 0;
              }
            }
          };

          /** Helper to read N bytes without consuming buffered data (only stream). */
          const readBytes = async (n) => {
            let result = new Uint8Array(n);
            let bytesRead = 0;

            if (bufferedData.length) {
              const copyLen = Math.min(n, bufferedData.length);
              result.set(bufferedData.subarray(0, copyLen), 0);
              bytesRead += copyLen;
              bufferedData = bufferedData.subarray(copyLen);
            }

            while (bytesRead < n) {
              const { value, done } = await reader.read();
              if (done) return null; // Stream ended unexpectedly
              const copyLen = Math.min(n - bytesRead, value.length);
              result.set(value.subarray(0, copyLen), bytesRead);
              bytesRead += copyLen;
              if (copyLen < value.length) {
                bufferedData = value.subarray(copyLen);
              }
            }
            return result;
          };

          await consumeBytes(metaInterval); // Skip audio data up to metadata block

          const metaSizeByte = await readBytes(1);
          if (!metaSizeByte) return icyStationName ? { stationName: icyStationName } : null;

          const metaSize = metaSizeByte[0] * 16; // Metadata length in bytes
          if (metaSize === 0) {
            return icyStationName ? { stationName: icyStationName } : null; // No metadata this block
          }

          const metaData = await readBytes(metaSize);
          // Try to abort the fetch as we have enough data
          try {
            controller.abort();
          } catch (e) {
            /* ignore error if already aborted/closed */
          }

          let metaString = "";
          try {
            metaString = new TextDecoder("latin1").decode(metaData); // ICY is often latin1
          } catch {
            try {
              metaString = new TextDecoder().decode(metaData); // Fallback to default
            } catch (e) {
              console.warn("Failed to decode ICY metadata:", e);
            }
          }

          const titleMatch =
            /StreamTitle='([^']*)'/.exec(metaString) ||
            /StreamTitle="([^"]*)"/.exec(metaString);
          const streamTitle = titleMatch ? titleMatch[1].trim() : "";

          return { title: streamTitle, stationName: icyStationName || "" };
        } catch (e) {
          // console.warn("ICY metadata probe failed:", e);
          return null; // On any error (network, abort, etc.), return null
        }
      }
    </script>
  </body>
</html>
